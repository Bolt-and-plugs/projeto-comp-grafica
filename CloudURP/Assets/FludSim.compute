#pragma kernel InitVelocityKernel
#pragma kernel InjectKernel
#pragma kernel AddSourceKernel
#pragma kernel AddVelocitySourceKernel
#pragma kernel AdvectKernel
#pragma kernel DiffuseKernel
#pragma kernel SetBoundaryKernel
#pragma kernel LifecycleKernel
#pragma kernel DivergenceKernel
#pragma kernel PressureJacobiKernel
#pragma kernel SubtractGradientKernel

// Sampler for filtered sampling of 3D textures
SamplerState sampler_linear_clamp;

// Grid dimensions (xyz) and dt
float4 gridSize;     // xyz used
float  deltaTime;

// ---------------- Velocity ----------------
RWTexture3D<float4> velocityWrite;  // For initialization / velocity sources
Texture3D<float4>  velocityRead;    // For sampling velocity

// ---------------- Density -----------------
Texture3D<float>   densityRead;
RWTexture3D<float> densityWrite;

// ---------------- Projection -----------------
RWTexture3D<float> divergenceWrite;
Texture3D<float>   divergenceRead;

RWTexture3D<float> pressureWrite;
Texture3D<float>   pressureRead;

// ---------------- Diffusion ---------------
Texture3D<float>   bufferRead;
Texture3D<float>   initialBuffer;
RWTexture3D<float> bufferWrite;
float alpha;
float rBeta;

// ---------------- Inject (procedural sphere) -------------
float3 injectPos;
float  injectRadius;
float  injectValue;

// ---------------- Add Source (generic textures) ----------
Texture3D<float>   sourceDensity;
float              sourceScale = 1.0;

Texture3D<float4>  sourceVelocity;
float              velocitySourceScale = 1.0;

// ---------------- Init --------------------
float3 initialVelocity;

// ---------------- Lifecycle ----------------
float decayRate; // How fast density fades (0.0 - 1.0)
float cellSize = 1.0;

// Utility: bounds check
bool InBounds(uint3 id, float3 size)
{
    return !(id.x >= size.x || id.y >= size.y || id.z >= size.z);
}

int3 GridSizeInt()
{
    return int3(gridSize.xyz);
}

float3 SampleVelocityZero(int3 coord, int3 grid)
{
    if (coord.x < 0 || coord.y < 0 || coord.z < 0 ||
        coord.x >= grid.x || coord.y >= grid.y || coord.z >= grid.z)
        return float3(0.0, 0.0, 0.0);

    return velocityRead.Load(int4(coord, 0)).xyz;
}

float SamplePressureClamp(int3 coord, int3 grid)
{
    coord = clamp(coord, int3(0,0,0), grid - int3(1,1,1));
    return pressureRead.Load(int4(coord, 0));
}

// Simple hash for procedural noise
float hash(float3 p)
{
    p = frac(p * 0.3183099 + 0.1);
    p *= 17.0;
    return frac(p.x * p.y * p.z * (p.x + p.y + p.z));
}

// 3D noise function
float noise(float3 x)
{
    float3 p = floor(x);
    float3 f = frac(x);
    f = f * f * (3.0 - 2.0 * f);
    
    return lerp(
        lerp(lerp(hash(p), hash(p + float3(1,0,0)), f.x),
             lerp(hash(p + float3(0,1,0)), hash(p + float3(1,1,0)), f.x), f.y),
        lerp(lerp(hash(p + float3(0,0,1)), hash(p + float3(1,0,1)), f.x),
             lerp(hash(p + float3(0,1,1)), hash(p + float3(1,1,1)), f.x), f.y), f.z);
}

// Fractal Brownian Motion for natural cloud-like patterns
float fbm(float3 p, int octaves)
{
    float value = 0.0;
    float amplitude = 0.5;
    float frequency = 1.0;
    
    for (int i = 0; i < octaves; i++)
    {
        value += amplitude * noise(p * frequency);
        frequency *= 2.0;
        amplitude *= 0.5;
    }
    return value;
}

// Hash 3D to 3D for Worley noise feature points
float3 hash3to3(float3 p)
{
    p = float3(dot(p, float3(127.1, 311.7, 74.7)),
               dot(p, float3(269.5, 183.3, 246.1)),
               dot(p, float3(113.5, 271.9, 124.6)));
    return frac(sin(p) * 43758.5453123);
}

// Worley noise (cellular) for realistic cloud puff structure
float worley(float3 p)
{
    float3 cell = floor(p);
    float3 f = frac(p);
    float minDist = 1.0;

    // Consider 27 neighbouring cells for feature points
    for (int z = -1; z <= 1; z++)
    for (int y = -1; y <= 1; y++)
    for (int x = -1; x <= 1; x++)
    {
        float3 neighbour = float3(x, y, z);
        float3 featurePoint = hash3to3(cell + neighbour);
        float3 offset = neighbour + featurePoint - f;
        float dist = length(offset);
        minDist = min(minDist, dist);
    }

    return minDist;
}

// Combined FBM + Worley pattern for organic clouds
float cloudDensityPattern(float3 p)
{
    float baseFBM = fbm(p * 0.05, 3);

    float worleyPattern = 1.0 - worley(p * 1);
    float detail = fbm(p * 0.2, 2) * 0.5;

    float density = baseFBM * worleyPattern + detail * 0.3;
    return saturate(density);
}

// Initialize velocity field to a constant vector
[numthreads(8,8,8)]
void InitVelocityKernel(uint3 id : SV_DispatchThreadID)
{
    float3 size = gridSize.xyz;
    if (!InBounds(id, size)) return;
    velocityWrite[id] = float4(initialVelocity, 0);
}

// Procedural spherical density injection
[numthreads(8,8,8)]
void InjectKernel(uint3 id : SV_DispatchThreadID)
{
    float3 size = gridSize.xyz;
    if (!InBounds(id, size)) return;

    float3 p = id;
    float d  = distance(p, injectPos);
    if (d < injectRadius)
    {
        float falloff = 1 - (d / injectRadius);
        
        // Combine sphere falloff with Worley + FBM pattern
        float3 noisePos = p ;
        float cloudNoise = cloudDensityPattern(noisePos);

        // Ensure strong core density while preserving cellular variation
        float densityShape = cloudNoise * 2;

        float finalDensity = injectValue * falloff * densityShape;
        finalDensity = max(0.0, finalDensity);
        
        float prev = densityWrite[id];
        densityWrite[id] = max(prev, finalDensity);
    }
}

// Adds a (pre-baked) source density texture into the current density (Stable Fluids add_source analog)
[numthreads(8,8,8)]
void AddSourceKernel(uint3 id : SV_DispatchThreadID)
{
    float3 size = gridSize.xyz;
    if (!InBounds(id, size)) return;

    float prev  = densityWrite[id];
    float addVal = sourceDensity[id] * sourceScale * deltaTime;
    
    // Limit maximum density to prevent infinite accumulation
    const float maxDensity = 1.5;
    float newDensity = prev + addVal;
    densityWrite[id] = min(newDensity, maxDensity);
}

// Adds a velocity source texture (optional)
[numthreads(8,8,8)]
void AddVelocitySourceKernel(uint3 id : SV_DispatchThreadID)
{
    float3 size = gridSize.xyz;
    if (!InBounds(id, size)) return;

    float4 prev = velocityWrite[id];
    float4 addv = sourceVelocity[id] * velocitySourceScale * deltaTime;
    velocityWrite[id] = float4(prev.xyz + addv.xyz, 0);
}

// Semi-Lagrangian advection for density
[numthreads(8,8,8)]
void AdvectKernel(uint3 id : SV_DispatchThreadID)
{
    float3 size = gridSize.xyz;
    if (!InBounds(id, size)) return;

    // Normalized coords to sample velocity
    float3 coord = (id + 0.5) / size;
    float3 vel = velocityRead.SampleLevel(sampler_linear_clamp, coord, 0).xyz;

    // Backtrace
    float clampedCell = max(cellSize, 1e-4);
    float velocityScale = deltaTime / clampedCell;
    float3 previous = (float3)id - vel * velocityScale;
    previous = clamp(previous, 0.0.xxx, size - 1.001.xxx);

    float3 prevNorm = (previous + 0.5) / size;
    float d = densityRead.SampleLevel(sampler_linear_clamp, prevNorm, 0);

    densityWrite[id] = d;
}

// Simple Jacobi diffusion iteration
[numthreads(8,8,8)]
void DiffuseKernel(uint3 id : SV_DispatchThreadID)
{
    float3 size = gridSize.xyz;
    // Skip boundary
    if (id.x < 1 || id.y < 1 || id.z < 1 ||
        id.x >= size.x - 1 || id.y >= size.y - 1 || id.z >= size.z - 1)
        return;

    float sumN =
        bufferRead[id + uint3(-1,0,0)] +
        bufferRead[id + uint3( 1,0,0)] +
        bufferRead[id + uint3(0,-1,0)] +
        bufferRead[id + uint3(0, 1,0)] +
        bufferRead[id + uint3(0,0,-1)] +
        bufferRead[id + uint3(0,0, 1)];

    float initVal = initialBuffer[id];
    float val = (sumN + alpha * initVal) * rBeta;

    // diffusion is rouding my clouds too much, clamp to previous value
    float prev = bufferRead[id];

    bufferWrite[id] = val;
}

// Sets density to zero on the boundaries
[numthreads(8,8,8)]
void SetBoundaryKernel(uint3 id : SV_DispatchThreadID)
{
    float3 size = gridSize.xyz;
    if (!InBounds(id, size)) return;
    
    // Zero nas bordas
    if (id.x == 0 || id.y == 0 || id.z == 0 ||
        id.x >= size.x - 1 || id.y >= size.y - 1 || id.z >= size.z - 1)
    {
        densityWrite[id] = 0.0;
    }
}

// Lifecycle: decay density over time
[numthreads(8,8,8)]
void LifecycleKernel(uint3 id : SV_DispatchThreadID)
{
    float3 size = gridSize.xyz;
    if (!InBounds(id, size)) return;
    
    float currentDensity = densityWrite[id];
    
    // Exponential decay over time
    float decay = exp(-decayRate * deltaTime);
    float newDensity = currentDensity * decay;
    
    // Force to zero if below threshold (prevents floating point accumulation)
    const float threshold = 0.001;
    if (newDensity < threshold)
        newDensity = 0.0;
    
    densityWrite[id] = newDensity;
}

// Compute velocity divergence (∇·u)
[numthreads(8,8,8)]
void DivergenceKernel(uint3 id : SV_DispatchThreadID)
{
    float3 size = gridSize.xyz;
    if (!InBounds(id, size)) return;

    int3 grid = GridSizeInt();
    int3 pos = int3(id);

    float3 velL = SampleVelocityZero(pos - int3(1,0,0), grid);
    float3 velR = SampleVelocityZero(pos + int3(1,0,0), grid);
    float3 velD = SampleVelocityZero(pos - int3(0,1,0), grid);
    float3 velU = SampleVelocityZero(pos + int3(0,1,0), grid);
    float3 velB = SampleVelocityZero(pos - int3(0,0,1), grid);
    float3 velF = SampleVelocityZero(pos + int3(0,0,1), grid);

    float halfInvCell = 0.5 / cellSize;
    float div = ((velR.x - velL.x) + (velU.y - velD.y) + (velF.z - velB.z)) * halfInvCell;

    divergenceWrite[id] = div;
    pressureWrite[id] = 0.0; // reset pressure accumulator
}

// Jacobi iteration to solve Poisson equation for pressure
[numthreads(8,8,8)]
void PressureJacobiKernel(uint3 id : SV_DispatchThreadID)
{
    float3 size = gridSize.xyz;
    if (!InBounds(id, size)) return;

    int3 grid = GridSizeInt();
    int3 pos = int3(id);

    // Clamp boundaries to zero pressure
    if (pos.x == 0 || pos.y == 0 || pos.z == 0 ||
        pos.x == grid.x - 1 || pos.y == grid.y - 1 || pos.z == grid.z - 1)
    {
        pressureWrite[id] = 0.0;
        return;
    }

    float left   = pressureRead.Load(int4(pos - int3(1,0,0), 0));
    float right  = pressureRead.Load(int4(pos + int3(1,0,0), 0));
    float down   = pressureRead.Load(int4(pos - int3(0,1,0), 0));
    float up     = pressureRead.Load(int4(pos + int3(0,1,0), 0));
    float back   = pressureRead.Load(int4(pos - int3(0,0,1), 0));
    float front  = pressureRead.Load(int4(pos + int3(0,0,1), 0));

    float divergenceVal = divergenceRead.Load(int4(pos, 0));
    float newPressure = (left + right + down + up + back + front - divergenceVal * cellSize * cellSize) / 6.0;
    pressureWrite[id] = newPressure;
}

// Subtract pressure gradient from velocity to enforce incompressibility
[numthreads(8,8,8)]
void SubtractGradientKernel(uint3 id : SV_DispatchThreadID)
{
    float3 size = gridSize.xyz;
    if (!InBounds(id, size)) return;

    int3 grid = GridSizeInt();
    int3 pos = int3(id);

    float pressureL = SamplePressureClamp(pos - int3(1,0,0), grid);
    float pressureR = SamplePressureClamp(pos + int3(1,0,0), grid);
    float pressureD = SamplePressureClamp(pos - int3(0,1,0), grid);
    float pressureU = SamplePressureClamp(pos + int3(0,1,0), grid);
    float pressureB = SamplePressureClamp(pos - int3(0,0,1), grid);
    float pressureF = SamplePressureClamp(pos + int3(0,0,1), grid);

    float invTwoCell = 0.5 / cellSize;
    float3 gradient = float3(pressureR - pressureL,
                             pressureU - pressureD,
                             pressureF - pressureB) * invTwoCell;

    float3 vel = velocityRead.Load(int4(pos, 0)).xyz - gradient;

    // Enforce solid boundaries: zero normal component at edges
    if (pos.x == 0 || pos.x == grid.x - 1) vel.x = 0.0;
    if (pos.y == 0 || pos.y == grid.y - 1) vel.y = 0.0;
    if (pos.z == 0 || pos.z == grid.z - 1) vel.z = 0.0;

    velocityWrite[id] = float4(vel, 0.0);
}


