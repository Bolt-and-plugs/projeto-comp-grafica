#pragma kernel InitVelocityKernel
#pragma kernel InjectKernel
#pragma kernel AddSourceKernel
#pragma kernel AddVelocitySourceKernel
#pragma kernel AdvectKernel
#pragma kernel DiffuseKernel
#pragma kernel SetBoundaryKernel
#pragma kernel LifecycleKernel

// Sampler for filtered sampling of 3D textures
SamplerState sampler_linear_clamp;

// Grid dimensions (xyz) and dt
float4 gridSize;     // xyz used
float  deltaTime;

// ---------------- Velocity ----------------
RWTexture3D<float4> velocityWrite;  // For initialization / velocity sources
Texture3D<float4>  velocityRead;    // For advection stage

// ---------------- Density -----------------
Texture3D<float>   densityRead;
RWTexture3D<float> densityWrite;

// ---------------- Diffusion ---------------
Texture3D<float>   bufferRead;
Texture3D<float>   initialBuffer;
RWTexture3D<float> bufferWrite;
float alpha;
float rBeta;

// ---------------- Inject (procedural sphere) -------------
float3 injectPos;
float  injectRadius;
float  injectValue;

// ---------------- Add Source (generic textures) ----------
Texture3D<float>   sourceDensity;
float              sourceScale = 1.0;

Texture3D<float4>  sourceVelocity;
float              velocitySourceScale = 1.0;

// ---------------- Init --------------------
float3 initialVelocity;

// ---------------- Lifecycle ----------------
float decayRate; // How fast density fades (0.0 - 1.0)

// Utility: bounds check
bool InBounds(uint3 id, float3 size)
{
    return !(id.x >= size.x || id.y >= size.y || id.z >= size.z);
}

// Simple hash for procedural noise
float hash(float3 p)
{
    p = frac(p * 0.3183099 + 0.1);
    p *= 17.0;
    return frac(p.x * p.y * p.z * (p.x + p.y + p.z));
}

// 3D noise function
float noise(float3 x)
{
    float3 p = floor(x);
    float3 f = frac(x);
    f = f * f * (3.0 - 2.0 * f);
    
    return lerp(
        lerp(lerp(hash(p), hash(p + float3(1,0,0)), f.x),
             lerp(hash(p + float3(0,1,0)), hash(p + float3(1,1,0)), f.x), f.y),
        lerp(lerp(hash(p + float3(0,0,1)), hash(p + float3(1,0,1)), f.x),
             lerp(hash(p + float3(0,1,1)), hash(p + float3(1,1,1)), f.x), f.y), f.z);
}

// Fractal Brownian Motion for natural cloud-like patterns
float fbm(float3 p, int octaves)
{
    float value = 0.0;
    float amplitude = 0.5;
    float frequency = 1.0;
    
    for (int i = 0; i < octaves; i++)
    {
        value += amplitude * noise(p * frequency);
        frequency *= 2.0;
        amplitude *= 0.5;
    }
    return value;
}

// Hash 3D to 3D for Worley noise feature points
float3 hash3to3(float3 p)
{
    p = float3(dot(p, float3(127.1, 311.7, 74.7)),
               dot(p, float3(269.5, 183.3, 246.1)),
               dot(p, float3(113.5, 271.9, 124.6)));
    return frac(sin(p) * 43758.5453123);
}

// Worley noise (cellular) for realistic cloud puff structure
float worley(float3 p)
{
    float3 cell = floor(p);
    float3 f = frac(p);
    float minDist = 1.0;

    // Consider 27 neighbouring cells for feature points
    for (int z = -1; z <= 1; z++)
    for (int y = -1; y <= 1; y++)
    for (int x = -1; x <= 1; x++)
    {
        float3 neighbour = float3(x, y, z);
        float3 featurePoint = hash3to3(cell + neighbour);
        float3 offset = neighbour + featurePoint - f;
        float dist = length(offset);
        minDist = min(minDist, dist);
    }

    return minDist;
}

// Combined FBM + Worley pattern for organic clouds
float cloudDensityPattern(float3 p)
{
    float baseFBM = fbm(p * 0.05, 3);
    float worleyPattern = 1.0 - worley(p * 0.1);
    float detail = fbm(p * 0.2, 2) * 0.5;

    float density = baseFBM * worleyPattern + detail * 0.3;
    return saturate(density);
}

// Initialize velocity field to a constant vector
[numthreads(8,8,8)]
void InitVelocityKernel(uint3 id : SV_DispatchThreadID)
{
    float3 size = gridSize.xyz;
    if (!InBounds(id, size)) return;
    velocityWrite[id] = float4(initialVelocity, 0);
}

// Procedural spherical density injection
[numthreads(8,8,8)]
void InjectKernel(uint3 id : SV_DispatchThreadID)
{
    float3 size = gridSize.xyz;
    if (!InBounds(id, size)) return;

    float3 p = id;
    float d  = distance(p, injectPos);
    if (d < injectRadius)
    {
        float falloff = 1 - (d / injectRadius);
        
        // Combine sphere falloff with Worley + FBM pattern
    float3 noisePos = p * 0.05;
    float cloudNoise = cloudDensityPattern(noisePos);

    // Ensure strong core density while preserving cellular variation
    float densityShape = 0.6 + 0.4 * cloudNoise;

    float finalDensity = injectValue * falloff * densityShape;
        finalDensity = max(0.0, finalDensity);
        
        float prev = densityWrite[id];
        densityWrite[id] = max(prev, finalDensity);
    }
}

// Adds a (pre-baked) source density texture into the current density (Stable Fluids add_source analog)
[numthreads(8,8,8)]
void AddSourceKernel(uint3 id : SV_DispatchThreadID)
{
    float3 size = gridSize.xyz;
    if (!InBounds(id, size)) return;

    float prev  = densityWrite[id];
    float addVal = sourceDensity[id] * sourceScale * deltaTime;
    
    // Limit maximum density to prevent infinite accumulation
    const float maxDensity = 1.5;
    float newDensity = prev + addVal;
    densityWrite[id] = min(newDensity, maxDensity);
}

// Adds a velocity source texture (optional)
[numthreads(8,8,8)]
void AddVelocitySourceKernel(uint3 id : SV_DispatchThreadID)
{
    float3 size = gridSize.xyz;
    if (!InBounds(id, size)) return;

    float4 prev = velocityWrite[id];
    float4 addv = sourceVelocity[id] * velocitySourceScale * deltaTime;
    velocityWrite[id] = float4(prev.xyz + addv.xyz, 0);
}

// Semi-Lagrangian advection for density
[numthreads(8,8,8)]
void AdvectKernel(uint3 id : SV_DispatchThreadID)
{
    float3 size = gridSize.xyz;
    if (!InBounds(id, size)) return;

    // Normalized coords to sample velocity
    float3 coord = (id + 0.5) / size;
    float3 vel = velocityRead.SampleLevel(sampler_linear_clamp, coord, 0).xyz;

    // Backtrace
    float3 previous = (float3)id - vel * deltaTime;
    previous = clamp(previous, 0.0.xxx, size - 1.001.xxx);

    float3 prevNorm = (previous + 0.5) / size;
    float d = densityRead.SampleLevel(sampler_linear_clamp, prevNorm, 0);

    densityWrite[id] = d;
}

// Simple Jacobi diffusion iteration
[numthreads(8,8,8)]
void DiffuseKernel(uint3 id : SV_DispatchThreadID)
{
    float3 size = gridSize.xyz;
    // Skip boundary
    if (id.x < 1 || id.y < 1 || id.z < 1 ||
        id.x >= size.x - 1 || id.y >= size.y - 1 || id.z >= size.z - 1)
        return;

    float sumN =
        bufferRead[id + uint3(-1,0,0)] +
        bufferRead[id + uint3( 1,0,0)] +
        bufferRead[id + uint3(0,-1,0)] +
        bufferRead[id + uint3(0, 1,0)] +
        bufferRead[id + uint3(0,0,-1)] +
        bufferRead[id + uint3(0,0, 1)];

    float initVal = initialBuffer[id];
    float val = (sumN + alpha * initVal) * rBeta;
    bufferWrite[id] = val;
}

// Sets density to zero on the boundaries
[numthreads(8,8,8)]
void SetBoundaryKernel(uint3 id : SV_DispatchThreadID)
{
    float3 size = gridSize.xyz;
    if (!InBounds(id, size)) return;
    
    // Zero nas bordas
    if (id.x == 0 || id.y == 0 || id.z == 0 ||
        id.x >= size.x - 1 || id.y >= size.y - 1 || id.z >= size.z - 1)
    {
        densityWrite[id] = 0.0;
    }
}

// Lifecycle: decay density over time
[numthreads(8,8,8)]
void LifecycleKernel(uint3 id : SV_DispatchThreadID)
{
    float3 size = gridSize.xyz;
    if (!InBounds(id, size)) return;
    
    float currentDensity = densityWrite[id];
    
    // Exponential decay over time
    float decay = exp(-decayRate * deltaTime);
    float newDensity = currentDensity * decay;
    
    // Force to zero if below threshold (prevents floating point accumulation)
    const float threshold = 0.001;
    if (newDensity < threshold)
        newDensity = 0.0;
    
    densityWrite[id] = newDensity;
}
