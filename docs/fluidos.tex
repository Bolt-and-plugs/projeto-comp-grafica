\section{Simulação de Fluidos em Computação Gráfica}

Os maiores desafios da simulação de fluidos está nos aspectos fisicos que se aplicam, como por exemplo, convecção, difusão, turbulência e tensão superficial \cite{desbrun1996}. No entanto, essas simulações eram (ao menos em 2003) quase inviáveis para serem empregadas em tempo real, portanto a precisão acaba sendo deixada parcialmente de lado nestas simulações.

A simulação de fluidos começou, basicamente, com a equação de de Navier-Stokes (que será abordada na seção \ref{sec:volumes}) que descrevem a dinamica dos fluidos (esse sistema de equações diferenciais se baseia em derivadas parciais e permitem determinar os campos de velocidade e de pressão num escoamento de fluidos). 

\subsection{Smoothed Particle Hydrodynamics}

Em 1983, T. Reeves \cite{reeves1983} introduziu sistemas de partículas como uma técnica para modelar uma classe de objetos difusos. Desde então, tanto a abordagem Lagrangiana baseada em partículas quanto a abordagem Euleriana baseada em grades têm sido usadas para simular fluidos em computação gráfica, como citado na seção \ref{sec:sis-part}. Desbrun e Cani \cite{desbrun1996} e Tonnesen \cite{tonnesen1998} utilizam partículas para animar objetos macios. As partículas também foram usadas para animar superfícies \cite{witkin1991}, controlar superfícies implícitas \cite{bloomenthal1997} e animar fluxos de lava \cite{carlson2002}. Nos últimos anos, a abordagem Euleriana tem sido mais popular para a simulação de fluidos em geral \cite{fedkiw2001}, água \cite{stam1999, foster1996, enright2002}, objetos macios \cite{muller2002} e efeitos de derretimento \cite{carlson2002}.

Em consonância, o artigo de Müller et al. (2003) \cite{muller2003} apresenta uma abordagem eficiente para simulação de fluidos baseada em Smoothed Particle Hydrodynamics (SPH). O método SPH representa o fluido como um conjunto de partículas, onde cada partícula carrega propriedades como massa, posição, velocidade e densidade. As interações entre partículas são calculadas usando funções de suavização (kernels), permitindo simular efeitos como pressão, viscosidade e forças externas.

As principais fórmulas utilizadas no SPH são:

\begin{itemize}
  \item Densidade: $$
\rho_i = \sum_j m_j W(|\mathbf{r}_i - \mathbf{r}_j|, h)
$$
onde $\rho_i$ é a densidade da partícula $i$, $m_j$ é a massa da partícula $j$, $W$ é o kernel de suavização e $h$ é o raio de influência.

\item Pressão: $$
\mathbf{f}_i^{\text{pressão}} = -\sum_j m_j \frac{p_i + p_j}{2 \rho_j} \nabla W(|\mathbf{r}_i - \mathbf{r}_j|, h)
$$
onde $p_i$ e $p_j$ são as pressões das partículas $i$ e $j$.

\item Viscosidade: $$
\mathbf{f}_i^{\text{visc}} = \mu \sum_j m_j \frac{\mathbf{v}_j - \mathbf{v}_i}{\rho_j} \nabla^2 W(|\mathbf{r}_i - \mathbf{r}_j|, h) $$ onde $\mu$ é o coeficiente de viscosidade e $\mathbf{v}_i$, $\mathbf{v}_j$ são as velocidades das partículas.
\end{itemize}

Essas fórmulas permitem calcular as forças que atuam sobre cada partícula, resultando em simulações de líquidos realistas e eficientes para aplicações interativas. Há de se notar, entretanto, que essas fórmulas tendem a ser muito custosas se implementadas conforme a descrição, sem otimização linear inclusa. Logo, diversos papers foram publicados visando manter qualidade suficiente, mas reduzindo o custo computacional e permitindo que essa simulação seja feita em tempo real. 


\subsection{Nuvens Volumétricas}
\label{sec:volumes}

Ao simular um fluído em tempo real, tem-se o desafio de preservar a performance computacional, sem perder muita qualidade visual. Para isso, técnicas de simulação Eulerianas baseadas em grades são frequentemente utilizadas,  onde o espaço é dividido em células (voxels) e as propriedades do fluído, como densidade, velocidade e pressão, são armazenadas em cada uma delas. Essas propriedades são então atualizadas ao longo do tempo usando métodos numéricos que resolvem as equações de Navier-Stokes, que governam o comportamento dos fluidos. Os volumes serão abordados aqui de 2 formas, modelagem de forma e shading, de maneira a se melhor representar materiais como fumaça, fogo, água, poeira, folhas, etc.

\subsubsection{Modelagem de forma}
No geral, ao se computar campos de particulas, espera-se que todas elas tenham seu tempo de vida bem definido para que se possa modelar de maneira precisa o seu comportamento. No entanto, em tempo real, esse trabalho se torna muito custoso. O movimento desses elementos passa a ser calculado, então, convertendo as velocidades que circulam o objeto em forças aplicadas sobre o corpo.

A poeira, por exemplo, pode ser modelada sendo carregada por um vetor de velocidades, sem que haja qualquer resistência significativa ou força externa a ser calculada. Entretanto, no caso da fumaça ou das nuvens, as particulas são substituidas pela simulação da densidade do fluido, que tenta aproximar a quantidade de particulas presentes no espaço (normalmente um valor entre 0 e 1). Essa descrição é dada pela função (conhecida como equação escalar de advecção-difusão):

$$
\frac{\partial \rho}{\partial t} = - (u \cdot \nabla) \rho + D \nabla^2 \rho + S
$$

Onde 
\begin{itemize}
  \item $\rho$ é a densidade de particulas, que varia no espaço e no tempo,
  \item $t$ é o tempo do sistema,
  \item $u$ é o campo de velocidades, ou seja, um vetor que indica a direção e a magnitude do movimento do fluido em cada ponto do espaço,
  \item $D$ é o coeficiente de difusão, que controla a taxa de dispersão das particulas no fluido (quanto maior o valor, mais rápido as particulas se espalham),
  \item $S$ é a fonte (ou sumidouro) de particulas,
  \item $\nabla$ é o operador nabla, que representa o gradiente espacial (uma medida de como a densidade muda no espaço),
  \item $\nabla^2$ é o operador laplaciano, que representa a difusão espacial (uma medida de como a densidade se espalha no espaço),
\end{itemize}

A \textbf{equação de advecção-difusão} pode ser resolvida numericamente alterando a grade supracitada, sendo sua resolução altamente importante para a precisão e o custo computacional da simulação, visto que grades mais finas proporcionam maior detalhe, mas exigem mais memória e poder de processamento. Segundo Stam et al \cite{Stam2003}, o método pode ser dividido em dois passos principais: o passo de densidade e o passo de velocidade, vistos a seguir.

\subsubsection*{Passo de Densidade}
O método linear (proposto por Stam at al \cite{Stam2003}) inicia-se com algum estado para as grades de velocidade e densidade e, então, atualiza seus valores baseado em eventos externos (forças, fonte de energia, fontes de particulas e etc.). Esse método se tornou famoso por ser estável para grandes passos de tempo (estabilidade incondicional) \footnote{Isso significa que, para qualquer valor positivo do passo de tempo, o método não produzirá resultados divergentes ou instáveis.}, o que é uma grande vantagem para simulações em tempo real. A cada passo de tempo, o método segue três etapas principais, passando pela equação de advecção-difusão de maneira "inversa", começando do termo final e indo para o inicial:

\begin{itemize}
  \item Primeiro termo (Source/Fonte): Adiciona densidade ao sistema baseado em fontes externas. Isso pode incluir a adição de fumaça de uma chaminé ou a introdução de calor em uma área específica.
  \item Segundo termo (Diffusion/Difusão): Simula a dispersão da densidade ao longo do tempo (se $D > 0$). Uma possível implementação é usar o método de Gauss-Seidel para resolver a equação de difusão, dada por 
    $$
    x_{k+1} = x_k + a \nabla^2 x_{k+1}
    $$
    onde $a$ é uma constante que depende do coeficiente de difusão e do passo de tempo. 

    Ou podemos usar o método de Jacobi, que é mais simples de implementar, mas pode ser menos eficiente. A equação de difusão usando o método de Jacobi é dada por:
    $$
    x_{k+1} = x_k + a \nabla^2 x_k
    $$

  \item Terceiro termo (Advection/Advecção): Podemos modelar o centro de cada célula da grade como se fosse uma particula que se move baseada na velocidade do campo. Assim, a densidade é transportada ao longo do campo de velocidades. Entretanto, temos que converter novamente as particulas para a celula proveniente. Uma maneira de fazer isso é usando o método de traçado de linha (backtrace), onde cada célula da grade é atualizada com a densidade da célula de onde a particula veio, baseado na velocidade do campo, ou seja, nos tracamos a linha de volta. Esse método é conhecido como "semi-Lagrangian advection" e é estável para grandes passos de tempo.

\end{itemize}

Temos como entrada na função o tamanho da matriz (N), a matriz de densidade atual (x), a matriz de densidade anterior (x0), as matrizes de velocidade (u e v), o coeficiente de difusão (diff) e o passo de tempo (dt). A função começa adicionando fontes de densidade, depois difunde a densidade e finalmente a advecta ao longo do campo de velocidades.

Percebe-se que, neste caso, temos 2 campos de velocidade (u e v), o que indica que estamos trabalhando em 2D. Para 3D, teríamos um terceiro campo de velocidade (w) e a função de advecção precisaria ser ajustada para levar isso em conta.

O código no final se aproxima disso:
\begin{lstlisting}[language=C]
void dens_step(int N, float *x, float *x0, 
float *u, float *v, float diff, float dt) {
  add_source (N, x, x0, dt);
  SWAP(x0, x); diffuse (N, 0, x, x0, diff, dt);
  SWAP(x0, x); advect (N, 0, x, x0, u, v, dt);
}
\end{lstlisting}


\subsubsection*{Passo de Velocidade}
O passo de velocidade é similar ao passo de densidade, mas com algumas diferenças importantes. Podemos dizer que a velocidade do campo se altera de 3 maneiras distintas: forças externas, difusão e advecção própria (ou auto-advecção - no qual o campo move a si mesmo). De maneira geral, pode ser descrito pela seguinte equação:

$$\frac{\partial u}{\partial t} = - (u \cdot \nabla) u + \nu \nabla^2 u + f - \frac{1}{\rho} \nabla p$$

Onde:
\begin{itemize}
  \item $u$ é o campo de velocidades,
  \item $t$ é o tempo do sistema,
  \item $\nu$ é o coeficiente de viscosidade (definido pelo usuário),
  \item $f$ é a força externa aplicada ao campo de velocidades,
  \item $(u \cdot \nabla)$ é o operador de advecção, que representa o transporte do campo de velocidades por ele mesmo,
  \item $\nabla^2$ é o operador laplaciano, que representa a difusão espacial do campo de velocidades.
  \item $\frac{1}{\rho} \nabla p$ é o termo de pressão, que representa a força devido à variação de pressão no fluido.
\end{itemize}

O código desta etapa pode ser escrito como:

\begin{lstlisting}[language=C]
void vel_step(int N, fl oat *u, float *v, 
float *u0, float *v0, float visc, float dt) {
  add_source(N, u, u0, dt); add_source(N, v, v0, dt);
  SWAP(u0, u); diffuse(N, 1, u, u0, visc, dt);
  SWAP(v0, v); diffuse(N, 2, v, v0, visc, dt);
  project(N, u, v, u0, v0);
  SWAP(u0, u); SWAP( v0, v);
  advect(N, 1, u, u0, u0, v0, dt);
  advect(N, 2, v, v0, u0, v0, dt);
  project(N, u, v, u0, v0);
}
\end{lstlisting}

Note que temos um novo procedimento neste passo chamado \texttt{project}, que é responsável por garantir que o campo de velocidades seja incompressível, ou seja, que a divergência do campo seja zero ($\nabla \cdot u = 0$) \footnote{A massa do fluido permanece constante ao longo do tempo.}. Isso é importante para simular fluidos realistas, onde a massa é conservada. Este método pode ser implementado resolvendo a equação de Poisson para o componente de pressão e, em seguida, ajustando o campo de velocidades com base no gradiente resultante.

O procedimento \texttt{project} calcula a pressão p que seria necessária para "empurrar" o excesso de massa para fora (ou puxar a falta de massa para dentro) e, em seguida, aplica a força de pressão ($-\nabla p$) para corrigir as velocidades e pode ser implementado da seguinte maneira:

\begin{lstlisting}[language=C]
void project(int N, float *u, float *v, float *p, float *div) {
  int i, j, k;
  float h = 1.0f / N;
  for (i = 1; i <= N; i++) {
    for (j = 1; j <= N; j++) {
      div[IX(i,j)] = -0.5f*h*(u[IX(i+1,j)]
      - u[IX(i-1,j)] + v[IX(i,j+1)] - v[IX(i,j-1)]);
      p[IX(i,j)] = 0;
    }
  }
  set_boundary(N, 0, div); set_boundary(N, 0, p);

  for (k = 0; k < 20; k++) {
    for (i = 1; i <= N; i++) {
      for (j = 1; j <= N; j++) {
        p[IX(i,j)] = (div[IX(i,j)] + p[IX(i-1,j)]
        + p[IX(i+1,j)] + p[IX(i,j-1)] + p[IX(i,j+1)]) / 4;
      }
    }
    set_boundary(N, 0, p);
  }

  for (i = 1; i <= N; i++) {
    for (j = 1; j <= N; j++) {
      u[IX(i,j)] -= 0.5f*(p[IX(i+1,j)] - p[IX(i-1,j)])/h;
      v[IX(i,j)] -= 0.5f*(p[IX(i,j+1)] - p[IX(i,j-1)])/h;
    }
  }
  set_boundary(N, 1, u); set_boundary(N, 2, v);
}
\end{lstlisting}

\subsubsection{Conclusão da modelagem de forma}
Podemos concluir essa seção com a presença de uma rotina principal, que chama os passos de densidade e velocidade, atualizando o estado do fluido a cada frame \footnote{A rotina \texttt{draw\_dens} será abordada na Seção \ref{sec:shading}.}.
\begin{lstlisting}[language=C]
void simulate(int N, float *u, float *v, float *u0, float *v0,
float *dens, float *dens0, float diff, float visc, float dt) {
  get_inputs(N, u0, v0, dens0);
  vel_step(N, u, v, u0, v0, visc, dt);
  dens_step(N, dens, dens0, u, v, diff, dt);
  draw_dens(N, dens);
}
\end{lstlisting}

\subsection{Shading}
\label{sec:shading}

Volumes são tradicionalmente renderizados usando soluções numéricas para a equação de rendering volumétrico, descrita a seguir:

$$
L(x_0, \omega) = \int_{0}^{t_{max}} (\sigma_s(X(t)) L_i(X(t), \omega) + L_e(X(t), \omega))e^{-\int_{0}^{t} \sigma_t(X(s)) ds} dt
$$

Onde
\begin{itemize}
  \item $L(x_0, \omega)$ é a radiância (cor) na posição $x_0$ na direção $\omega$,
  \item $t_{max}$ é a distância máxima que o raio percorre no volume,
  \item $X(t) = x_0 + t\omega$ é a posição ao longo do raio,
  \item $\sigma_s(X(t))$ é o coeficiente de espalhamento no ponto $X(t)$,
  \item $L_i(X(t), \omega)$ é a radiância incidente no ponto $X(t)$ na direção $\omega$,
  \item $L_e(X(t), \omega)$ é a radiância emitida no ponto $X(t)$ na direção $\omega$,
  \item $\sigma_t(X(s)) = \sigma_a(X(s)) + \sigma_s(X(s))$ é o coeficiente de atenuação total no ponto $X(s)$, que é a soma dos coeficientes de absorção ($\sigma_a$) e espalhamento ($\sigma_s$),
  \item $e^{-\int_{0}^{t} \sigma_t(X(s)) ds}$ é o termo de atenuação, que representa a redução da radiância devido à absorção e espalhamento ao longo do caminho do raio.
\end{itemize}

Uma abordagem comum é o método de \textbf{\textit{ray marching}}, onde um raio é lançado através do volume e amostras são coletadas ao longo do caminho do raio. Essas amostras são então usadas para calcular a cor e a opacidade do pixel correspondente na imagem final.

\subsubsection{Interação da luz com volumes}

Vamos tratar dos fenomenos físicos descritos pela equação de rendering volumétrico, passando por absorção, emissão e espalhamento e como eles podem ser implementados em um sistema de ray marching.

\begin{itemize}
  \item Absorção: A luz é absorvida pelo meio, reduzindo sua intensidade. Isso é descrito pela lei de Beer-Lambert:
  $$
  I(t) = I_0 e^{-\int_{0}^{t} \sigma_a(s) ds}
  $$
  onde $I(t)$ é a intensidade da luz no ponto $t$, $I_0$ é a intensidade inicial, e $\sigma_a(s)$ é o coeficiente de absorção no ponto $s$.
  
  \item Emissão: O meio pode emitir luz, contribuindo para a intensidade total. A contribuição da emissão pode ser modelada como:
  $$
  L_{emit}(t) = \int_{0}^{t} j(s) e^{-\int_{s}^{t} \sigma_a(u) du} ds
  $$
  onde $j(s)$ é a taxa de emissão no ponto $s$.
  
  \item Espalhamento: A luz pode ser espalhada em diferentes direções ao interagir com o meio. O espalhamento pode ser descrito pela função de fase $p(\omega', \omega)$, que define a probabilidade de um raio de luz ser espalhado da direção $\omega'$ para a direção $\omega$. A contribuição do espalhamento pode ser modelada como:
  $$
  L_{scatter}(t) = \int_{0}^{t} \sigma_s(s) \int_{S^2} p(\omega', \omega) L(s, \omega') d\omega' e^{-\int_{s}^{t} \sigma_a(u) du} ds
  $$
  onde $\sigma_s(s)$ é o coeficiente de espalhamento no ponto $s$, e $L(s, \omega')$ é a radiância incidente na direção $\omega'$ no ponto $s$ \cite{Kajiya1984}.
\end{itemize}

Todas essas técnicas se acumulam na equação de rendering volumétrico expressa no inicio da seção \ref{sec:shading}. A implementação das técnicas de solução numérica pode variar dependendo do contexto específico e dos requisitos de desempenho e qualidade visual, mas o objetivo geral é capturar a complexidade da interação da luz com volumes de maneira eficiente e realista, mantendo a precisão física e sem fritar o seu chip gráfico.

\subsubsection{Implementação básica de ray marching}
Trataremos agora de uma implementação básica de ray marching para volumes, que incorpora os conceitos de absorção, emissão e espalhamento discutidos anteriormente. 
Essa implementação envolve o lançamento de um raio através do volume e a amostragem da densidade e outras propriedades do volume ao longo do caminho do raio. O código a seguir ilustra uma implementação do comportamento esperado:

\begin{lstlisting}[language=C]
vec4 ray_march(vec3 ray_origin, vec3 ray_direction,
float t_near, float t_far) {
  vec4 color = vec4(0.0);
  float t = t_near;
  float step_size = 0.1;
  while (t < t_far) {
    vec3 sample_position = ray_origin + t * ray_direction;
    float density = sample_density(sample_position);
    vec4 sample_color = compute_color(density);
    color += sample_color * exp(-density * step_size);
    t += step_size;
  }
  return color;
}
\end{lstlisting}

Este código define uma função `ray\_march` que toma a origem e a direção do raio, bem como os limites próximo e distante do volume. A função itera ao longo do caminho do raio, amostrando a densidade do volume em cada passo e acumulando a cor resultante, levando em consideração a absorção da luz. A função `sample\_density` é responsável por retornar a densidade do volume em uma posição específica, enquanto a função `compute\_color` calcula a cor com base na densidade amostrada. A variável `step\_size` controla a distância entre as amostras ao longo do raio, e pode ser ajustada para equilibrar a qualidade visual e o desempenho. Note que esta é uma implementação simplificada e pode ser expandida para incluir efeitos adicionais, como emissão e espalhamento, conforme discutido anteriormente \cite{Pharr2016}.
